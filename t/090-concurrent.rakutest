use v6;
use Test;
use AttrX::Mooish;

# Make sure we have enough threads in pool on low-cores CPUs.
BEGIN PROCESS::<$SCHEDULER> = ThreadPoolScheduler.new(:max_threads(100));

plan 2;

subtest "Concurrent instantiation" => {
    plan 4;

    my $repeats = 10000;
    my $workers = 20;

    my class Foo {
        has atomicint $.builds = 0;
        has Int $.foo is mooish(:lazy, :clearer, :predicate);

        method build-foo {
            ++⚛$!builds;
            42
        }
    }

    my $cnt-lock = Lock.new;

    my $fetches-total = 0;
    my $inits-total = 0;
    my $nonset-total = 0;
    my $predicate-total = 0;

    sub run-test {
        my $fetch-ok = 0;
        my $inits-ok = 0;
        my $predicate-ok = 0;
        my $nonset-ok = 0;
        for ^$repeats {
            my $inst = Foo.new;
            ++$nonset-ok unless $inst.has-foo;
            ++$fetch-ok if $inst.foo == 42;
            ++$predicate-ok if $inst.has-foo;
            $inst.clear-foo;
            ++$nonset-ok unless $inst.has-foo;
            ++$fetch-ok if $inst.foo == 42;
            $inits-ok += $inst.builds;
        }
        $cnt-lock.protect: {
            $inits-total += $inits-ok;
            $fetches-total += $fetch-ok;
            $predicate-total += $predicate-ok;
            $nonset-total += $nonset-ok;
        }
    }

    my @w-ready;
    my $starter = Promise.new;
    my @p;
    for ^$workers -> $id {
        @w-ready[$id] = Promise.new;
        @p.push: start {
            @w-ready[$id].keep;
            await $starter;
            run-test;
        }
    }

    await @w-ready;
    $starter.keep;
    await @p;

    my $expected = $workers * $repeats;
    is $inits-total, 2 * $expected, "all inits passed";
    is $fetches-total, 2 * $expected, "all fetches passed";
    is $predicate-total, $expected, "all predicates passed";
    is $nonset-total, 2 * $expected, "all non-set passed";
}

subtest "Concurrent lazy builds" => {
    my $thread-count = 100;
    plan 6;
    my class Foo {
        has $.foo is mooish(:lazy, :clearer);
        has atomicint $.builds-ran = 0;

        method build-foo {
            ++⚛$!builds-ran;
        }

        method reset {
            self.clear-foo;
            $!builds-ran ⚛= 0;
        }
    }

    sub access-test($inst) {
        my $starter = Promise.new;

        my @workers;
        my @w-ready;

        my @values;
        my $val-lock = Lock::Async.new;

        for ^100 -> $thread-id {
            @w-ready.push: my $ready = Promise.new;
            @workers.push: start {
                $ready.keep(True);
                await $starter;
                # Initialize concurrent read from the attribute.
                my $v = $inst.foo;
                $val-lock.protect: { @values.push: $v };
            }
        }

        await @w-ready;
        $starter.keep(True);
        await @workers;
        is $inst.builds-ran, 1, "build was ran exactly once per instance";
        is $inst.foo, 1, "initialized with the number of builds invoked";
        # This is to make sure there is nothing wrong about the attribute build logic.
        is-deeply @values.List, 1 xx $thread-count, "all threads got the same value";
    }

    my $foo = Foo.new;
    my $*AXM-DEBUG = 1;
    access-test($foo);
    $foo.reset;
    access-test($foo);
}

done-testing;
